var s=(i,r,t)=>new Promise((e,o)=>{var a=c=>{try{d(t.next(c))}catch(u){o(u)}},m=c=>{try{d(t.throw(c))}catch(u){o(u)}},d=c=>c.done?e(c.value):Promise.resolve(c.value).then(a,m);d((t=t.apply(i,r)).next())});import{readdirSync as N,statSync as R}from"fs";import{resolve as L,join as v}from"path";import{readdirSync as I,statSync as D}from"fs";import{resolve as b,join as _}from"path";var n={full_path:!1};import{resolve as E}from"path";var f=(i,r)=>i.replace(E(r),"");import{existsSync as S}from"fs";var h=(t=>(t.DIRECTORY_NOT_EXIST="Directory not exist",t.INVALID_PATH="Invalid path",t))(h||{});var g=i=>S(i)?{status:!0}:{error:"Directory not exist",status:!1};var y=class{constructor(r,t=n){this.target_folder=r;this.options=t}getFolders(r){let t=b(r);return I(t).filter(e=>D(_(t,e)).isDirectory()).map(e=>this.options.full_path?_(t,e):_(this.target_folder,f(t,this.target_folder),e))}getAllFolders(){let r=[...this.getFolders(this.target_folder)];for(let t=0;t<r.length;t++)r.push(...this.getFolders(r[t]));return r}},F=(i,r=n)=>{let{status:t,error:e}=g(i);if(!t)throw new Error(e);return new y(i,r).getAllFolders()};var O=class{constructor(r,t=n){this.target_folder=r;this.options=t}filter(r,t){if(!R(v(r,t)).isFile())return!1;if(!this.options.filter)return!0;let{filter:e}=this.options;return e instanceof RegExp?e.test(t):e(t)}getFiles(r){let t=L(r);return N(t).map(o=>{if(this.filter(t,o))return this.options.full_path?v(t,o):v(this.target_folder,f(t,this.target_folder),o)}).filter(Boolean)}getAllFiles(){let r=[...this.getFiles(this.target_folder)];return F(this.target_folder).forEach(t=>{r=r.concat(this.getFiles(t))}),r}},U=(i,r=n)=>{let{status:t,error:e}=g(i);if(!t)throw new Error(e);return new O(i,r).getAllFiles()};import{readdir as X,stat as Y}from"fs/promises";import{resolve as H,join as A}from"path";import{readdir as j,stat as B}from"fs/promises";import{resolve as C,join as x}from"path";var w=class{constructor(r,t=n){this.target_folder=r;this.options=t}getFolders(r){return s(this,null,function*(){let t=C(r),o=(yield j(t)).map(a=>s(this,null,function*(){let m=x(t,a);if((yield B(m)).isDirectory())return this.options.full_path?m:x(this.target_folder,f(t,this.target_folder),a)}));return(yield Promise.all(o)).filter(Boolean)})}getAllFolders(){return s(this,null,function*(){let r=[...yield this.getFolders(this.target_folder)];for(let t=0;t<r.length;t++)r.push(...yield this.getFolders(r[t]));return r})}},T=(t,...e)=>s(void 0,[t,...e],function*(i,r=n){let{status:o,error:a}=g(i);if(!o)throw new Error(a);return yield new w(i,r).getAllFolders()});var P=class{constructor(r,t=n){this.target_folder=r;this.options=t}filter(r,t){return s(this,null,function*(){if(!(yield Y(A(r,t))).isFile())return!1;if(!this.options.filter)return!0;let{filter:e}=this.options;return e instanceof RegExp?e.test(t):e(t)})}getFiles(r){return s(this,null,function*(){let t=H(r),e=(yield X(t)).map(o=>s(this,null,function*(){if(yield this.filter(t,o))return this.options.full_path?A(t,o):A(this.target_folder,f(t,this.target_folder),o)}));return(yield Promise.all(e)).filter(Boolean)})}getAllFiles(){return s(this,null,function*(){let r=yield this.getFiles(this.target_folder),e=(yield T(this.target_folder)).map(a=>s(this,null,function*(){return yield this.getFiles(a)})),o=yield Promise.all(e);return r.concat(...o)})}},V=(t,...e)=>s(void 0,[t,...e],function*(i,r=n){let{status:o,error:a}=g(i);if(!o)throw new Error(a);return yield new P(i,r).getAllFiles()});export{h as MessageError,V as getFilesAsync,U as getFilesSync,T as getFoldersAsync,F as getFoldersSync};
